[
["introduction.html", "Google Earth Engine workshop Introduction Earth Engine access Earth Engine help Workshop code Source", " Google Earth Engine workshop Philip Kraaijenbrink October 6, 2020 Introduction I developed this content originally in September 2018 for an internal workshop at the Department of Physical Geography of Utrecht University. The exercises of this workshop are meant to give you an idea of the capabilities of Google Earth Engine. Some code uses intermediate to advanced concepts and because of the different level of the workshop participants, all code has been pre-written and ready for copy-paste. More advanced participants are encouraged to dive deeper into the code, add additional code, and find their own solutions, and help others in understanding the analyses and code. Earth Engine access To use Google Earth Engine you need to sign up for the service first using a Google account. Earth Engine help There are various ways you can search for help on Earth Engine coding, among others: Function help is available through the docs tab on the top left panel of the web interface. A concise user guide with clear examples is accessible via the help dropdown menu in the top right corner of the web interface. The developer discussion group is accessible via the help dropdown menu in the top right corner of the web interface. It has many discussions on a plethora of topics and often with example code written by other developers. Community-driven tutorials and training material are available from Google. Workshop code A script repository that holds working code of all the exercises as well as of additional cases can be added to your own Earth Engine environment using the following URL: https://code.earthengine.google.com/?accept_repo=users/philipkraaijenbrink/dpg-workshop My earthengine-tools repository contains additional functions that are called by the scripts in this manual. To review this code and/or assess its functionality you can visit: https://github.com/kraaijenbrink/earthengine-tools Source The source code of this manual, exercises and cases is available at: https://github.com/kraaijenbrink/earthengine-workshop © 2020 Philip Kraaijenbrink. This document is licensed under the Creative Commons Attribution-ShareAlike 4.0 International license (CC BY-SA 4.0) "],
["image-classification.html", "1 Image classification 1.1 Define input data 1.2 Obtain training data 1.3 Classify image 1.4 Visualize using charts", " 1 Image classification Generate a Landsat 8 composite image, perform a land cover classification of the image, and compare class distribution over elevation in the Netherlands. 1.1 Define input data First you will need to define the datasets to use. In this exercise you will use Landsat 8 surface reflectance data, AHN elevation data, and vector outlines of the Netherlands and dutch provinces. Copy and paste the lines below to a blank script: // get landsat data from catalog var landsat = ee.ImageCollection(&#39;LANDSAT/LC08/C01/T1_SR&#39;) // get only scenes that overlap with NL, have less than 10% cloud cover, and // fall in the period 2015-2017 var nl = ee.FeatureCollection(&#39;users/philipkraaijenbrink/dpg-workshop/rijksgrens_nl&#39;) var landsat = landsat.filterBounds(nl) .filterDate(&#39;2015-01-01&#39;,&#39;2017-12-31&#39;) .filter(ee.Filter.lte(&#39;CLOUD_COVER&#39;, 10)) // select subsat of image bands and rename them for easier reference // first select band subset, then loop over images in collection and rename the bands var landsat = landsat .select([&#39;B2&#39;,&#39;B3&#39;,&#39;B4&#39;,&#39;B5&#39;,&#39;B6&#39;,&#39;B7&#39;,&#39;B10&#39;]) .map(function(x){return x.rename([&#39;blue&#39;,&#39;green&#39;,&#39;red&#39;, &#39;nir&#39;,&#39;swir1&#39;,&#39;swir2&#39;,&#39;tir&#39;])}) To get a quick cloud free composite of the filtered Landsat 8 image collection, use a median reducer to generate a single composite image whose pixels comprise the median value of the collection. Using the median makes sure that the cloud pixels are not selected because they are always close to the maximum values. // for every pixel, get the median pixel value of all images in the collection // for a quick way to filter clouds and possible artefacts var satimg = landsat.median() // clip the result to the outline of NL var satimg = satimg.clip(nl) 1.2 Obtain training data Visualize the data using Map.addLayer(), similar to example code on the previous page. Select a band combination that clearly shows the different land cover types. To perform classification of the composite image you first need to define training data. This is performed by drawing polygons on the image to sample pixels of a land cover class. In this exercise you will classify the following classes: grassland, forest, water, built-up, bare, cropland Draw polygons for each of the land cover classes using the drawing tools of Earth Engine (in the top left corner of the map). Do not make the polygon too large and try to limit contamination by pixels that are not supposed to be part of the class, e.g. do not let the built-up polygon partly cover a park. For each class, you should generate a new layer. In the layer settings (accessible via the gear icon that appears when hovering over the layer) give the layer a name, set the import type to ‘feature’ and add a property “class”. Set the class value for each cover type to a unique numerical value (0 to 5). If necessary, there can be multiple polygons per class. Don’t mind the colors for now, you will assign them in a later stage. Figure 1.1: Drawing tools and layers currently drawn. Figure 1.2: The geometry settings dialog. When you have created the polygons for all classes, combine them into a feature collection using the following code (check whether the layer names match yours). // combine the sample regions you&#39;ve create into a single collection var sampleregs = ee.FeatureCollection([grass,forest,water,built_up,bare,crop]) 1.3 Classify image Using the polygons, we will now sample pixels from the image and use them as training data for the classification algorithm. You will use a simple minimum distance classifier, but there are many more advanced options available. To generate the classified image use: // selection of bands to use for classification algorithm var bands = [&#39;green&#39;,&#39;red&#39;,&#39;nir&#39;,&#39;swir1&#39;,&#39;swir2&#39;] // sample pixels from the image using the regions var training = satimg.sampleRegions({ collection: sampleregs, properties: [&#39;class&#39;], scale: 30 }) // define classifier and train with the samples var mdmodel = ee.Classifier.minimumDistance(&#39;euclidean&#39;) var trained = mdmodel.train(training, &#39;class&#39;, bands) // apply classifier to the image var classimg = satimg.classify(trained) Define a list with class names, values and display colors to use for mapping and charting: // lists with class names, values and colors (for colors use hex RGB or html5 color names) var classlab = [&#39;Grassland&#39;,&#39;Forest&#39;,&#39;Water&#39;,&#39;Built-up&#39;,&#39;Bare&#39;,&#39;Cropland&#39;] var classval = [0,1,2,3,4,5] var classcol = [&#39;YellowGreen&#39;, &#39;184930&#39;, &#39;LightSkyBlue&#39;, &#39;#cacaca&#39;, &#39;Moccasin&#39;, &#39;OliveDrab&#39;] Add the classification to the map using: Map.addLayer(classimg, {min:0, max:5, palette: classcol}, &#39;Classification&#39;,true) If you would like, you can add a quick legend to the map using this predefined function: var lg = require(&#39;users/philipkraaijenbrink/tools:legends&#39;) lg.classLegend(classval, classlab, classcol) Evaluate the classification accuracy. Has it performed well? If not, change your polygons and/or add extra. 1.4 Visualize using charts To get information about the class distribution in the Netherlands, generate a barchart showing approximate area per class. This can be done using the following code: // chart that shows class area distribution var nl = ee.FeatureCollection(&#39;users/philipkraaijenbrink/dpg-workshop/rijksgrens_nl&#39;) var chart = ui.Chart.image.byClass({ image: ee.Image.pixelArea().multiply(1e-6) // pixel area in km2 .addBands(classimg.rename(&#39;classification&#39;)), classBand: &#39;classification&#39;, region: nl, reducer: ee.Reducer.sum(), scale: 30*30, classLabels: classlab, }) chart.setOptions({title:&#39;Area per class&#39;, hAxis: {title: &#39;&#39;}, vAxis: {title: &#39;Area (km2)&#39;}, colors: classcol}) .setChartType(&#39;ColumnChart&#39;) print(chart) To get a sense of class distribution with elevation in the Netherlands, first extract elevation bands from the detailed 0.5 m resolution elevation model Algemeen Hoogtebestand Nederland (AHN): // get equidistant elevation bands from AHN for charting var elev = ee.Image(&#39;AHN/AHN2_05M_INT&#39;) // get AHN dataset from catalog var stepping = 1.0 // elevation step size var elevsteps = ee.List.sequence(-5,50,stepping) // get steps in range var itr = ee.List.sequence(0,elevsteps.length().subtract(1),1) // iterator list to loop over var elevbands = ee.ImageCollection.fromImages(itr.map(function(i){ // loop over iterator i var elevthres = ee.Number(elevsteps.get(i)) // get elev_i var elevband = elev.lte(elevthres).and(elev.gt(elevthres.subtract(stepping))) // elev band var onlyband = elevband.updateMask(elevband.eq(1)) // mask everything but true return onlyband.set(&#39;system:index&#39;,ee.Number.parse(i).format(&#39;%04d&#39;)) // set image index })) Make a chart of the elevation bands that evaluates the area per class per elevation band: // make chart of pixel count per class per elevation band var chart = ui.Chart.image.byClass({ image: elevbands.toBands().addBands(classimg.rename(&#39;classification&#39;)), classBand: &#39;classification&#39;, region: nl, reducer: ee.Reducer.sum(), scale: 30*30, classLabels: classlab, xLabels: elevsteps.getInfo(), }) chart.setOptions({title:&#39;Land cover with elevation&#39;, hAxis: {title: &#39;Elevation (m)&#39;}, lineWidth: 2, pointSize: 0, colors: classcol, isStacked: &#39;absolute&#39;}) .setChartType(&#39;AreaChart&#39;) print(chart) To determine the fractional coverage of each elevation band, change the string absolute to relative or percent in the setOptions() function in the code above. You can also summarize images for every region in a vector dataset using ui.Chart.image.byRegion(). For example class area per province in the Netherlands: // make a chart for class distribution in each province var prov = ee.FeatureCollection(&#39;users/philipkraaijenbrink/dpg-workshop/provincies_nl&#39;) var sepclass = ee.Image(ee.List(classval).iterate( function(x,y){return ee.Image(y).addBands(classimg.eq(ee.Image.constant(x)))}, ee.Image().select())) var chartlab = []; classval.forEach(function(val,i){chartlab.push(val+&#39; &#39;+classlab[i])}); var chart = ui.Chart.image.byRegion({ image: sepclass.rename(chartlab), regions: prov, reducer: ee.Reducer.sum(), scale: 30*30, xProperty: &#39;provincien&#39;, }).setChartType(&#39;ColumnChart&#39;).setOptions({colors: classcol, isStacked: &#39;percent&#39;}) print(chart) "],
["quality-mosaicking.html", "2 Quality mosaicking 2.1 Define input data 2.2 Mask clouds and calculate index 2.3 Quality mosaic composite 2.4 Classify water", " 2 Quality mosaicking Use a quality mosaicking approach to get both a low tide and high tide image composite, and classify water using simple thresholding on water index to generate a map showing intertidal area. 2.1 Define input data First we need to define the datasets that we will use. In this exercise you will use Landsat 8 top of atmosphere reflectance data. Copy and paste the lines below to a blank script: // Settings ====================================== var cloudcov = 20; var imageQ = 8; // get data var ls8rfl = ee.ImageCollection(&quot;LANDSAT/LC08/C01/T1_TOA&quot;); var westerschelde = ee.Geometry.Point(3.83,51.42); // filter the landsat 8 collection and rename bands var ls8rfl = ls8rfl .filter(ee.Filter.lte(&#39;CLOUD_COVER&#39;,cloudcov)) .filter(ee.Filter.gte(&#39;IMAGE_QUALITY_OLI&#39;,imageQ)) .map(function(x){ return x.select([&#39;B2&#39;,&#39;B3&#39;,&#39;B4&#39;,&#39;B5&#39;,&#39;B6&#39;,&#39;B10&#39;,&#39;B7&#39;,&#39;BQA&#39;]) .rename([&#39;blue&#39;,&#39;green&#39;,&#39;red&#39;,&#39;nir&#39;,&#39;swir1&#39;,&#39;tir&#39;,&#39;swir2&#39;, &#39;bqa&#39;]) }); 2.2 Mask clouds and calculate index Often satellite imagery comes with metadata on the quality of the acquired imagery. This can be overall quality indication, such as used above, but also a quality image band, which holds predetermined information on quality of each pixel in the image. Using the cloud and cloud shadow flags in this band, the cloud pixels can be masked for each image in a loop over the image collection. Because you will need a water index per image in the analysis later on, it is calculated directly in the same loop. The water index that is calculated here is the Normalized Difference Water Index (NDWI), which ranges from -1 (no water) to 1 (water). // apply cloud mask on per-image basis and add Normalized Difference Water Index band var util = require(&#39;users/philipkraaijenbrink/tools:utilities&#39;) // load philip&#39;s util functions var lsmasked = ls8rfl.map(function(x){ // loop over image collection var cldmask = util.getQAFlags(x.select(&#39;bqa&#39;),4,4,&#39;clouds&#39;) // get cloud mask from QA band var shdmask = util.getQAFlags(x.select(&#39;bqa&#39;),7,8,&#39;shadow&#39;) // get cloud shadow mask var masked = x.updateMask(cldmask.eq(0)) // apply both masks to the image .updateMask(shdmask.lte(1)) var index = x.normalizedDifference([&#39;green&#39;, &#39;nir&#39;]) // calculate NDWI .rename(&#39;index&#39;) var invindex = ee.Image.constant(0).subtract(index) .rename(&#39;invindex&#39;)// get inverted index return masked.addBands(index).addBands(invindex) // return masked image incl. index bands }) 2.3 Quality mosaic composite Using the cloud masked imagery, you can now reduce the image collection to two image composites by sorting, on a pixel level, the Landsat images in the collection using the calculated NDWI values. This is performed using qualityMosaic() (see doc), which determines for each pixel in the composite image the image in the collection that has the maximum pixel value for the band specified. // for each spatial pixel select the image that has the lowest/highest NDWI value // in the entire (filtered) LS8 image collection var minwat = lsmasked.qualityMosaic(&#39;invindex&#39;); var maxwat = lsmasked.qualityMosaic(&#39;index&#39;); var meanwat = lsmasked.mean(); Add the data to the map and inspect the results: // add data to map Map.centerObject(westerschelde, 11); var vis_params = {min:0, max:0.3, bands:[&#39;swir1&#39;,&#39;nir&#39;,&#39;green&#39;]}; Map.addLayer(minwat, vis_params, &#39;LT composite&#39;, true); Map.addLayer(maxwat, vis_params, &#39;HT composite&#39;, false); Map.addLayer(meanwat, vis_params, &#39;Mean composite&#39;, false); 2.4 Classify water Classification of water areas can be performed by applying a threshold on the NDWI values of the image composite. Here, classify the pixels as water when \\(\\rm{NDWI}&gt;=0.2\\). This will create a boolean land-use map with two classes: water = 1, land = 0. // classify water on both images using NDWI threshold var lotide = minwat.select(&#39;index&#39;).gte(0.2); var hitide = maxwat.select(&#39;index&#39;).gte(0.2); // inspect classifications Map.addLayer(lotide, {palette:[&#39;darkgreen&#39;,&#39;lightblue&#39;]}, &#39;Low tide&#39;,true); Map.addLayer(hitide, {palette:[&#39;darkgreen&#39;,&#39;lightblue&#39;]}, &#39;High tide&#39;,true); Are you satisfied with the classification results? A better classification can probably be achieved by not selecting the extreme values of the NDWI to generate the image composite (qualityMosaic() function). To do so, a custom index must be constructed than can be passed to qualityMosaic(), for instance one based on percentiles of NDWI. The function below calculates a low and high NDWI percentile at each pixel based on all images in the filtered image collection. It then determines the difference between the NDWI of each image, at each pixel, with those percentile values. To get the index than can be passed to qualityMosaic(), one takes the absolute of the differences and inverts it, so that the smallest difference becomes the largest value. // Quite some noise in both classifications because qualitymosaicking picks up the extremes // Try to improve by using percentiles instead. Percentiles determined by trial and error // get image with low and high percentile NDWI var indexperc = lsmasked.select([&#39;index&#39;]).reduce(ee.Reducer.percentile([16,99], [&#39;lo&#39;,&#39;hi&#39;])); // loop over image collection var lsmasked = lsmasked.map(function(x){ // get absolute difference of the percentiles with the NDWI var selector = x.select(&#39;index&#39;).subtract(indexperc).abs(); // invert to let the min diff be the largest value var invsel = ee.Image.constant(1).divide(selector); // add inverted difference band to the image and name properly return x.addBands(invsel.rename([&#39;selector_lo&#39;,&#39;selector_hi&#39;])) }); // use the new selectors to perform the quality mosaic and add to map var minwat2 = lsmasked.qualityMosaic(&#39;selector_lo&#39;); var maxwat2 = lsmasked.qualityMosaic(&#39;selector_hi&#39;); Map.addLayer(minwat2, {min:0, max:0.3, bands:[&#39;swir1&#39;,&#39;nir&#39;,&#39;green&#39;]}, &#39;LT composite v2&#39;, true); Map.addLayer(maxwat2, {min:0, max:0.3, bands:[&#39;swir1&#39;,&#39;nir&#39;,&#39;green&#39;]}, &#39;HT composite v2&#39;, true); Have a look at the new image composites. This looks much better! They will probably also help to clean up the classification: // classify water on both images using NDWI threshold var lotide2 = minwat2.select(&#39;index&#39;).gte(0.2); var hitide2 = maxwat2.select(&#39;index&#39;).gte(0.2); // inspect classifications Map.addLayer(lotide2, {palette:[&#39;darkgreen&#39;,&#39;lightblue&#39;]}, &#39;Low tide 2&#39;,true); Map.addLayer(hitide2, {palette:[&#39;darkgreen&#39;,&#39;lightblue&#39;]}, &#39;High tide 2&#39;,true); The intertidal area is than the area that is submerged during high tide (hitide2 = 1), but not submerged during low tide (lotide 2 = 0). Using this Boolean logic, combine both water classifications and subsequently mask out all pixels that are not part of the intertidal area: // combine with boolean logic to get intertidal area, and mask everything but intertidal var intertidal = lotide2.eq(0).and(hitide2.eq(1)); var intertidal = intertidal.updateMask(intertidal); // add to map Map.addLayer(intertidal, {palette:[&#39;red&#39;]}, &#39;Intertidal area&#39;,true, 0.75); To get a simple proxy for the time that the intertidal beds are submerged during each tide you can use the NDWI value of the mean Landsat composite (average situation): // use masked mean NDWI of the entire collection to get a proxy for //the time the intertidal beds are submerged var subtime = meanwat.select(&#39;index&#39;).updateMask(intertidal); var vis_params = {min:-0.1, max:0.4, palette: [&#39;red&#39;,&#39;yellow&#39;,&#39;blue&#39;]}; Map.addLayer(subtime, vis_params, &#39;Submerged time&#39;, true); The code works well, with some limitations, for the Western Scheldt estuary. However, Earth Engine allows and advertises with ‘planetary scale analysis’. Visit some other places to see if the code is transferable and scalable (tip: use the search bar as if you were in google maps). For example, check out the Wadden Sea or St. Malo. "],
["regression.html", "3 Regression 3.1 Settings and data 3.2 Derive annual composites 3.3 Calculate temporal trend", " 3 Regression Perform a regression analysis on MODIS Normalized Difference Vegetation Index to observe the spatial distribution of greening and drying over the last two decades. 3.1 Settings and data Set some time settings and load the required data. The filter options allow you to filter on specific years and months as specified by the user in the time settings. You can play around with the time settings. For example, alter these settings such that you acquire NDVI trends for the summer period for the years 2010 to 2015. // time settings var yearrange = [2000,2017]; // limit calculations to specific range of years var monthrange = [1,12]; // limit calculations to specific range of months // load MODIS NDVI collection var ndvi = ee.ImageCollection(&quot;MODIS/006/MOD13A1&quot;); // Filter collection ndvi = ndvi.filterDate(yearrange[0]+&#39;-01-01&#39;,yearrange[1]+&#39;-12-31&#39;) .filter(ee.Filter.calendarRange(monthrange[0],monthrange[1], &#39;month&#39;)) .select(&#39;NDVI&#39;) A scaling factor is applied to the original data in the catalog (0.0001). To get the correct NDVI value, this factor first must be applied to each image in the filtered collection with the code below. Type “MODIS/006/MOD13A1” in the search bar, select the top result and look at the band descriptions of this dataset where the scaling factors are defined. Most image properties are lost when you apply reducers or arithmetic functions to images. To retain the time information that is stored with each image the system:time_start property is transferred using the set and get functions. // scale appropriately ndvi = ndvi.map(function(x){ return x.multiply(0.0001).set(&#39;system:time_start&#39;, x.get(&#39;system:time_start&#39;)) }); 3.2 Derive annual composites Annual mean NDVI images can be produced with the following code. It loops over a list of years, applies a time filter to the image collection in each loop, calculates a mean composite, and adds the current year as a constant image band. // Perform temporal reduction to get yearly mean NDVI images var years = ee.List.sequence(yearrange[0],yearrange[1]); var yearmeans = ee.ImageCollection.fromImages( years.map(function (yr){ return ndvi.filterDate(ee.Date.fromYMD(yr,1,1),ee.Date.fromYMD(yr,12,31)) .mean() .set(&#39;year&#39;,yr) .set(&#39;monthrange&#39;,monthrange[0]+&#39;-&#39;+monthrange[1]) .set(&#39;system:time_start&#39;, ee.Date.fromYMD(yr,1,1)) // add image band with the year to use in the regression .addBands(ee.Image.constant(yr).rename(&#39;yr&#39;).float()) }) ) var grandmean = yearmeans.select(&#39;NDVI&#39;).mean() 3.3 Calculate temporal trend Using the function ee.Reducer.linearFit() a linear regression between two image bands can be performed, in this case the years and the NDVI. This provides us with the slope and offset of the regression, or the a and b coefficients in the equation for an univariate linear regression: \\(y=ax+b\\) // compute a linear fit between years and NDVI var fit = yearmeans.select(&quot;yr&quot;,&quot;NDVI&quot;).reduce(ee.Reducer.linearFit()); In order to obtain probability values to determine the significance of the relation between years and NDVI, calculate the Pearson correlation using the following code: // compute Pearson&#39;s correlation coefficient and probability value var cor = yearmeans.select(&quot;yr&quot;,&quot;NDVI&quot;).reduce(ee.Reducer.pearsonsCorrelation()); Use my predifined R, Matlab, Matplotlib or Colorbrewer color palettes and legend functions to create a pretty map that shows you where greening or drying has occurred (NDVI trend map) and whether this trend is significant (p-value map). // load philip&#39;s color palette and legend tools // run cp.allPalettes() to show all color palettes that are available. var cp = require(&#39;users/philipkraaijenbrink/tools:colorpals&#39;) var lg = require(&#39;users/philipkraaijenbrink/tools:legends&#39;) If you would like to use another color palette, run cp.allPalettes() to print all available color palettes to the console // map the layers Map.centerObject(ee.Geometry.Point(95,30),5) Map.addLayer(grandmean, {min:0.0, max:0.7, palette:cp.getPalette(&quot;YlGn&quot;,9)}, &#39;NDVI&#39;,1) Map.addLayer(fit, {min: -0.006, max: 0.006, bands:&#39;scale&#39;, palette: cp.getPalette(&quot;PiYG&quot;,9)}, &#39;NDVI trends&#39;, 0); Map.addLayer(cor, {min:-1, max:1, bands:&#39;correlation&#39;, palette: cp.getPalette(&quot;RdBu&quot;,9)}, &#39;Correlation&#39;, 0); Map.addLayer(cor.lte(0.05), {min: &#39;0&#39;, max: &#39;1&#39;, bands: &#39;p-value&#39;, palette: [&#39;lightgray&#39;,&#39;darkgreen&#39;]}, &#39;p&lt;=0.05&#39;, 0); // create legends lg.rampLegend(cp.getPalette(&quot;YlGn&quot;,9),0,0.7, &#39;NDVI (-)&#39;) lg.rampLegend(cp.getPalette(&quot;PiYG&quot;,9), -6e-3,6e-3, &#39;NDVI trend (y-1)&#39;) lg.rampLegend(cp.getPalette(&quot;RdBu&quot;,9),-1,1, &#39;Correlation (-)&#39;) lg.classLegend(undefined, [&#39;False&#39;,&#39;True&#39;], [&#39;lightgray&#39;,&#39;darkgreen&#39;], &#39;Significance&#39;) "],
["climate-data-analysis.html", "4 Climate data analysis 4.1 Define input data 4.2 Estimate mean temperature 4.3 Determine relative change 4.4 Make charts 4.5 End of century climatology", " 4 Climate data analysis Examine the expected global temperature rise and precipitation changes in the 21st century, aggregate them by country and make a simple global climate change classification. 4.1 Define input data For this you will use yearly ensemble aggregates of the NEX-GDDP dataset, which is downscaled CMIP5 climate model data. The NEX-GDDP dataset includes daily projections for RCP4.5 and RCP8.5 from 21 Global Circulation Models within CMIP5. The projections include daily minimum temperature, maximum temperature and precipitation for the period 1950–2099. The spatial resolution of the NEX-GDDP dataset is 0.25 degrees (approximately 27 by 27 km at the equator). The original NEX-GDDP data is present in the Earth Engine catalog. For the purpose of this exercise, however, I have pre-aggregated it to yearly data and calculated model ensemble statistics using Google Earth Engine’s computing power. Load the pre-aggregated NEX-GDDP data, MODIS water mask and custom code: // load data var nexy = ee.ImageCollection(&#39;users/philipkraaijenbrink/climate-data/nex-gddp-yearly-stats&#39;) var wmask = ee.Image(&#39;MODIS/MOD44W/MOD44W_005_2000_02_24&#39;).select(&#39;water_mask&#39;) // load custom code var lg = require(&#39;users/philipkraaijenbrink/tools:legends&#39;) var cp = require(&#39;users/philipkraaijenbrink/tools:colorpals&#39;) 4.2 Estimate mean temperature Unfortunately, the NEX-GDDP dataset only has minimum and maximum daily temperatures (tasmin, tasmax). For most climate analyses mean daily temperature is used, so you will need to approximate the mean temperature as the average of tasmin and tasmax. Note that this is not accurate and that large deviations are expected, both in space and time. For the purpose of this exercise, however, it will suffice. // approximate mean temperature above surface for RCP45 and RCP85, // and store as multiband band image together with precipitation var start = 2006 // 2006 is start of future for CMIP5 var end = 2099 var absstack = ee.ImageCollection.fromImages(ee.List.sequence(start,end).map(function(i){ i = ee.Number(i) var curdat = nexy.filterDate(ee.Date.fromYMD(i,1,1),ee.Date.fromYMD(i,12,31)) var t45 = curdat.filter(ee.Filter.eq(&#39;scenario&#39;,&#39;rcp45&#39;)).first() .select([&#39;tasmin_mean&#39;,&#39;tasmax_mean&#39;]) .reduce(ee.Reducer.mean()) .rename(&#39;tas45&#39;) var t85 = curdat.filter(ee.Filter.eq(&#39;scenario&#39;,&#39;rcp85&#39;)).first() .select([&#39;tasmin_mean&#39;,&#39;tasmax_mean&#39;]) .reduce(ee.Reducer.mean()) .rename(&#39;tas85&#39;) var p45 = curdat.filter(ee.Filter.eq(&#39;scenario&#39;,&#39;rcp45&#39;)).first() .select([&#39;pr_mean&#39;]).rename(&#39;pr45&#39;) var p85 = curdat.filter(ee.Filter.eq(&#39;scenario&#39;,&#39;rcp85&#39;)).first() .select([&#39;pr_mean&#39;]).rename(&#39;pr85&#39;) var stack = ee.Image([t45,t85,p45,p85]).set(&#39;system:time_start&#39;, ee.Date.fromYMD(i,1,1)) return stack.updateMask(wmask.eq(0)) // limit the analysis to land masses })) 4.3 Determine relative change To estimate climate changes that may occur over the course of the 21st century you will need to determine the difference of each year with the climate at the beginning of the century, i.e. the reference climate. It is best practice to determine the difference with a multi-year reference climatology, but for the sake of this exercise you will simply use the first year. // for each image determine the relative difference with first timestep to get delta T and delta P var relstack = absstack.map(function(x){ var baseval = absstack.filterDate(ee.Date.fromYMD(start,1,1), ee.Date.fromYMD(start,12,31)) .first() var deltatas = x.select([&quot;tas45&quot;,&quot;tas85&quot;]) .subtract(baseval.select([&quot;tas45&quot;,&quot;tas85&quot;])) // dT (K) var deltapr = x.select([&quot;pr45&quot;,&quot;pr85&quot;]) .subtract(baseval.select([&quot;pr45&quot;,&quot;pr85&quot;])) .divide(x.select([&quot;pr45&quot;,&quot;pr85&quot;])).multiply(100) // dP (%) return ee.Image([deltatas,deltapr]) .set(&#39;system:time_start&#39;, x.get(&#39;system:time_start&#39;)) }) 4.4 Make charts You can now create charts of global temperature and precipitation changes relative to 2006 for the two climate scenarios. Add the code below and press run. // make charts with global average relative climate change for land masses var glob = ee.Geometry.Polygon([-180,-85,180,-85,180,85,-180,85,-180,-85], &#39;EPSG:4326&#39;, false); var tchart = ui.Chart.image.series( relstack.select([&#39;tas45&#39;,&#39;tas85&#39;]), glob, ee.Reducer.mean(), 50000 ) .setChartType(&#39;LineChart&#39;) .setOptions({lineWidth: 3, colors: [&#39;6b93ce&#39;,&#39;af6262&#39;]}); var pchart = ui.Chart.image.series( relstack.select([&#39;pr45&#39;,&#39;pr85&#39;]), glob, ee.Reducer.mean(), 50000 ) .setChartType(&#39;LineChart&#39;) .setOptions({lineWidth: 3, colors: [&#39;6b93ce&#39;,&#39;af6262&#39;]}); print(tchart); print(pchart); To show a graph of the absolute mean temperature and precipitation over the period 2006–2099 you could change the data that is plotted by changing relstack to absstack in the above code. 4.5 End of century climatology Future climate projections are often analysed for specific points in the future instead of transient data. Examples are middle of century (MOC) or end of century (EOC). To limit effects of interannual variability in the data, these points are calculated as climatologies of multiple years. EOC is therefore not just the year 2099, but the mean of 2071–2100. Calculate the average change in temperature and precipitation for the EOC, add the resulting images for RCP8.5 scenario to the map and inspect the results. // get end of century (EOC) climatology var eocmean = relstack.filterDate(&#39;2071-01-01&#39;,&#39;2099-12-31&#39;).mean() // define color palettes to use for tas and pr var tcol = cp.getPalette(&#39;InfernoMPL&#39;,9) var pcol = cp.getPalette(&#39;RdBu&#39;,5) // add eoc stats to map Map.addLayer(eocmean.select(&quot;tas85&quot;), {min:0, max:8, palette: tcol}, &#39;RCP85 dT EOC (K)&#39;) Map.addLayer(eocmean.select(&quot;pr85&quot;), {min:-100, max:100, palette: pcol}, &#39;RCP85 dP EOC (%)&#39;) // add legends to the map lg.rampLegend(tcol, 0,8, &#39;dT EOC (K)&#39;) lg.rampLegend(pcol, -100, 100, &#39;dP EOC (%)&#39;) To get a sense of climate change impacts in European countries, aggregate the temperature change results by using country polygons. A country dataset is already available in the Earth Engine catalog (Large Scale International Boundaries from the United States Office of the Geographer). // get warming per country and add to map var countries = ee.FeatureCollection(&#39;USDOS/LSIB_SIMPLE/2017&#39;) countries = countries.filter(ee.Filter.eq(&#39;wld_rgn&#39;,&#39;Europe&#39;)) var countrydeltas = eocmean.reduceRegions(countries,ee.Reducer.mean(),50000) var dTcountry = ee.Image().float().paint(countrydeltas,&#39;tas85&#39;) // paint poly fill on empty image var borders = ee.Image().byte().paint(countries,0,1) // paint country borders on empty image Map.addLayer(dTcountry, {min:0, max:8, palette: tcol}, &#39;dT EOC countries&#39;) Map.addLayer(borders,{},&#39;Country borders&#39;) Finally, make a simple classification of global climate change, given the RCP8.5 scenario. Use four classes: (1) dryer and above average warming, (2) dryer and below average warming, (3) wetter and above average warming, (4) wetter and below average warming. // make simple end of century classification var globmean = eocmean.reduceRegion(ee.Reducer.mean(), glob, 50000) // get global averages for EOC var dryhot = eocmean.select(&#39;pr85&#39;).lt(0) .and(eocmean.select(&#39;tas85&#39;).gte(ee.Image.constant(globmean.get(&#39;tas85&#39;)))) var drycold = eocmean.select(&#39;pr85&#39;).lt(0) .and(eocmean.select(&#39;tas85&#39;).lt(ee.Image.constant(globmean.get(&#39;tas85&#39;)))) var wethot = eocmean.select(&#39;pr85&#39;).gte(0) .and(eocmean.select(&#39;tas85&#39;).gte(ee.Image.constant(globmean.get(&#39;tas85&#39;)))) var wetcold = eocmean.select(&#39;pr85&#39;).gte(0) .and(eocmean.select(&#39;tas85&#39;).lt(ee.Image.constant(globmean.get(&#39;tas85&#39;)))) var classes = ee.Image.constant(0).byte() .where(dryhot,0).where(drycold,1).where(wethot,2).where(wetcold,3) .updateMask(wmask.eq(0)) var classnames = [&#39;dryer and relatively hot&#39;,&#39;dryer and relatively cold&#39;, &#39;wetter and relatively hot&#39;,&#39;wetter and relatively cold&#39;] var classcolors = [&#39;#f76754&#39;,&#39;#f7c054&#39;, &#39;#2f6837&#39;,&#39;#3d8ca0&#39;] Map.addLayer(classes, {min:0,max:3,palette:classcolors}, &#39;EOC classes&#39;) lg.classLegend(undefined, classnames, classcolors,&#39;EOC classes&#39;) "],
["additional-cases.html", "Additional cases", " Additional cases Here you will find some additional example code displaying Earth Engine’s capabilities. River planform dynamics 2018 drought anomalies in the Netherlands Coastline extraction Köppen-Geiger for future climate Urban expansion detection Note that the code for the cases above as well as for all exercises can be found at: https://github.com/kraaijenbrink/earthengine-workshop "]
]
